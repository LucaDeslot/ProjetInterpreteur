#include "Interpreteur.h"
#include "SymboleValue.h"

#include <cstdio>
#include <iomanip>
#include <iostream>
#include <string>

using namespace std;

Interpreteur::Interpreteur(ifstream & fichier) :
    m_lecteur(fichier), m_table(), m_arbre(nullptr)
{
}

void Interpreteur::analyse()
{
  m_arbre = programme(); // on lance l'analyse de la première règle
  if (m_arbre == nullptr)
  {
    throw SyntaxeException();
  }
}

void Interpreteur::tester(string const & symboleAttendu) const noexcept(false)
{
  // Teste si le symbole courant est égal au symboleAttendu... Si non, lève une exception
  static char messageWhat[256];
  if (m_lecteur.getSymbole() != symboleAttendu)
  {
    sprintf(
        messageWhat,
        "Ligne %d, Colonne %d - Erreur de syntaxe : Symbole attendu : '%s' -> Symbole trouvé : '%s'",
        m_lecteur.getLigne(), m_lecteur.getColonne(), symboleAttendu.c_str(),
        m_lecteur.getSymbole().getChaine().c_str());
    throw SyntaxeException(messageWhat);
  }
}

void Interpreteur::testerEtAvancer(string const & symboleAttendu) noexcept(false)
{
  // Teste si le symbole courant est égal au symboleAttendu... Si oui, avance, Sinon, lève une exception
  tester(symboleAttendu);
  m_lecteur.avancer();
}

void Interpreteur::erreur(string const & message) const noexcept(false)
{
  // Lève une exception contenant le message et le symbole courant trouvé
  // Utilisé lorsqu'il y a plusieurs symboles attendus possibles...
  static char messageWhat[256];
  sprintf(messageWhat,
          "Ligne %d, Colonne %d - Erreur de syntaxe : %s -> Symbole trouvé : '%s'",
          m_lecteur.getLigne(), m_lecteur.getColonne(), message.c_str(),
          m_lecteur.getSymbole().getChaine().c_str());
  throw SyntaxeException(messageWhat);
}

void Interpreteur::traduitCpp(unsigned int ind, ostream& out)
{
  out << setw(4 * ind) << "";
  out << "// generated by Ludovic J and Luca D Compiler ;)" << endl << endl;

  out << setw(4 * ind) << "";
  out << "#include <iostream>" << endl << setw(4 * ind) << "" << "#include <string>" << endl;
  out << setw(4 * ind) << "";
  out << endl << "using namespace std;" << endl << endl;
  out << setw(4 * ind) << "";
  out << "int main(int argc, char** argv) {" << endl;

  out << setw(4 * ind) << "";
  out << "// Corps" << endl;
  getArbre()->traduitCpp(ind + 1, out);
  out << setw(4 * ind) << "";
  out << "    return 0;" << endl;
  out << setw(4 * ind) << "";
  out << "}" << endl;
}

bool Interpreteur::isInst(Symbole symb) const
{
  return symb == "<VARIABLE>" || symb == "si" || symb == "tantque" || symb == "repeter"
      || symb == "pour" || symb == "ecrire" || symb == "lire" || symb == "selon";
}

Noeud* Interpreteur::programme()
{
  // <programme> ::= procedure principale() <seqInst> finproc FIN_FICHIER
  testerEtAvancer("procedure");
  testerEtAvancer("principale");
  testerEtAvancer("(");
  testerEtAvancer(")");
  Noeud* sequence = seqInst();
  try
  {
    testerEtAvancer("finproc");
  } catch (exception& e)
  {
    cerr << e.what() << endl << endl;

    while (m_lecteur.getSymbole() != "<FINDEFICHIER>" && m_lecteur.getSymbole() != "finproc")
    {
      while (m_lecteur.getSymbole() != "<FINDEFICHIER>" && !isInst(m_lecteur.getSymbole()))
      {
        m_lecteur.avancer();
      }
      seqInst();
    }
    testerEtAvancer("finproc");
  }
  tester("<FINDEFICHIER>");
  return sequence;
}

Noeud* Interpreteur::seqInst()
{
  // <seqInst> ::= <inst> { <inst> }
  NoeudSeqInst* sequence = new NoeudSeqInst();
  bool error = false;
  do
  {
    Noeud* noeud = inst();
    if (!noeud)
    {
      error = true;
      if (sequence)
        delete sequence;
      sequence = nullptr;
    }

    if (!error)
    {
      sequence->ajoute(noeud);
    }
  } while (isInst(m_lecteur.getSymbole()));
  // Tant que le symbole courant est un début possible d'instruction...
  // Il faut compléter cette condition chaque fois qu'on rajoute une nouvelle instruction
  return sequence;
}

Noeud* Interpreteur::inst()
{
  // <inst> ::= <affectation>  ; | <instSi>
  try
  {
    if (m_lecteur.getSymbole() == "<VARIABLE>")
    {
      Noeud *affect = affectation();
      testerEtAvancer(";");
      return affect;
    }
    else if (m_lecteur.getSymbole() == "si")
    {
      return instSi();
    }
    else if (m_lecteur.getSymbole() == "tantque")
    {
      return instTantQue();
    }
    else if (m_lecteur.getSymbole() == "repeter")
    {
      return instRepeter();
    }
    else if (m_lecteur.getSymbole() == "pour")
    {
      return instPour();
    }
    else if (m_lecteur.getSymbole() == "ecrire")
    {
      return instEcrire();
    }
    else if (m_lecteur.getSymbole() == "lire")
    {
      return instLire();
    }
    else if (m_lecteur.getSymbole() == "selon")
    {
      return instSelon();
    }
    else
    {
      erreur("Instruction incorrecte");
    }
  } catch (exception const &e)
  {
    cerr << e.what() << endl << endl;
    while (m_lecteur.getSymbole() != "<FINDEFICHIER>" && !isInst(m_lecteur.getSymbole()))
    {
      m_lecteur.avancer();
    }
  }
  return nullptr;
}

Noeud* Interpreteur::affectation()
{
  // <affectation> ::= <variable> = <expression>
  bool error = false;
  try
  {
    Noeud * var;
    try
    {
      tester("<VARIABLE>");
      var = m_table.chercheAjoute(m_lecteur.getSymbole()); // La variable est ajoutée à la table eton la mémorise
    } catch (exception e)
    {
      cerr << e.what() << endl << endl;
      m_lecteur.avancer();
      error = true;
    }
    m_lecteur.avancer();
    try
    {
      testerEtAvancer("=");
    } catch (exception const &e)
    {
      cerr << e.what() << endl << endl;
      m_lecteur.avancer();
      error = true;
    }
    Noeud* exp = expBool();             // On mémorise l'expression trouvée
    if (!error)
    {
      return new NoeudAffectation(var, exp); // On renvoie un noeud affectation
    }
  } catch (exception const &e)
  {
    cerr << e.what() << endl << endl;
  }
  return nullptr;
}

Noeud* Interpreteur::expression()
{
  // <expression> ::= <facteur> { <opBinaire> <facteur> }
  //  <opBinaire> ::= + | - | *  | / | < | > | <= | >= | == | != | et | ou
  Noeud* term = terme();
  while (m_lecteur.getSymbole() == "+" || m_lecteur.getSymbole() == "-")
  {
    Symbole operateur = m_lecteur.getSymbole(); // On mémorise le symbole de l'opérateur
    m_lecteur.avancer();
    Noeud* termDroit = terme(); // On mémorise l'opérande droit
    term = new NoeudOperateurBinaire(operateur, term, termDroit); // Et on construit un noeud opérateur binaire
  }
  return term; // On renvoie fact qui pointe sur la racine de l'expression
}

Noeud* Interpreteur::terme()
{
  // <terme>::= <facteur> { * <facteur> | / <facteur>}

  Noeud* fact = facteur();
  while (m_lecteur.getSymbole() == "*" || m_lecteur.getSymbole() == "/")
  {
    Symbole operateur = m_lecteur.getSymbole(); // On mémorise le symbole de l'opérateur
    m_lecteur.avancer();
    Noeud* termDroit = facteur(); // On mémorise l'opérande droit
    fact = new NoeudOperateurBinaire(operateur, fact, termDroit); // Et on construit un noeud opérateur binaire
  }
  return fact;
}

Noeud* Interpreteur::facteur()
{
  // <facteur> ::= <entier> | <variable> | - <facteur> | non <facteur> | ( <expression> )
  Noeud* fact = nullptr;
  if (m_lecteur.getSymbole() == "<VARIABLE>" || m_lecteur.getSymbole() == "<ENTIER>"
      || m_lecteur.getSymbole() == "<chaine>")
  {
    fact = m_table.chercheAjoute(m_lecteur.getSymbole()); // on ajoute la variable ou l'entier ou le string à la table
    m_lecteur.avancer();
  }
  else if (m_lecteur.getSymbole() == "-")
  { // - <facteur>
    m_lecteur.avancer();
    // on représente le moins unaire (- facteur) par une soustraction binaire (0 - facteur)
    fact = new NoeudOperateurBinaire(Symbole("-"), m_table.chercheAjoute(Symbole("0")),
                                     expBool());
  }
  else if (m_lecteur.getSymbole() == "non")
  { // non <facteur>
    m_lecteur.avancer();
    // on représente le moins unaire (- facteur) par une soustractin binaire (0 - facteur)
    fact = new NoeudOperateurBinaire(Symbole("non"), expBool(), nullptr);
  }
  else if (m_lecteur.getSymbole() == "(")
  { // expression parenthésée
    m_lecteur.avancer();
    fact = expBool();
    testerEtAvancer(")");
  }
  else
    erreur("Facteur incorrect");
  return fact;
}

Noeud* Interpreteur::expBool()
{
  // <expBool>::= <relationET> { ou <relationEt> }
  Noeud* expB = relationEt();
  while (m_lecteur.getSymbole() == "ou")
  {
    Symbole operateur = m_lecteur.getSymbole(); // On mémorise le symbole de l'opérateur
    m_lecteur.avancer();
    Noeud* termDroit = relationEt(); // On mémorise l'opérande droit
    expB = new NoeudOperateurBinaire(operateur, expB, termDroit); // Et on construit un noeud opérateur binaire
  }
  return expB;
}

Noeud* Interpreteur::relationEt()
{
  // <relationEt>::= <relation> { et <relation> }
  Noeud* relEt = relation();
  while (m_lecteur.getSymbole() == "et")
  {
    Symbole operateur = m_lecteur.getSymbole(); // On mémorise le symbole de l'opérateur
    m_lecteur.avancer();
    Noeud* termDroit = relation(); // On mémorise l'opérande droit
    relEt = new NoeudOperateurBinaire(operateur, relEt, termDroit); // Et on construit un noeud opérateur binaire
  }
  return relEt;
}

Noeud* Interpreteur::relation()
{
  // <relation>::= <expression> { <opRel> <expression>}
  Noeud* rela = expression();
  while (opRel())
  {
    Symbole operateur = m_lecteur.getSymbole(); // On mémorise le symbole de l'opérateur
    m_lecteur.avancer();
    Noeud* termDroit = expression(); // On mémorise l'opérande droit
    rela = new NoeudOperateurBinaire(operateur, rela, termDroit); // Et on construit un noeud opérateur binaire
  }
  return rela;
}

/*
 * m_lecteur.getSymbole() == "<" || m_lecteur.getSymbole() == "<="
 || m_lecteur.getSymbole() == ">" || m_lecteur.getSymbole() == ">="
 || m_lecteur.getSymbole() == "==" || m_lecteur.getSymbole() == "!="
 */
bool Interpreteur::opRel()
{
  return m_lecteur.getSymbole() == "<" || m_lecteur.getSymbole() == "<="
      || m_lecteur.getSymbole() == ">" || m_lecteur.getSymbole() == ">="
      || m_lecteur.getSymbole() == "==" || m_lecteur.getSymbole() == "!=";
}

Noeud* Interpreteur::instSi()
{
  // <instSi> ::= si ( <expression> ) <seqInst> finsi
  testerEtAvancer("si");
  testerEtAvancer("(");
  Noeud* condition = expBool(); // On mémorise la condition
  testerEtAvancer(")");
  Noeud* sequence = seqInst();     // On mémorise la séquence d'instruction
  Noeud *noeudSi = new NoeudInstSi(condition, sequence); //create the node for if (basic)

  // le sinonsi sequence
  while (m_lecteur.getSymbole() == "sinonsi")
  {
    testerEtAvancer("sinonsi");
    testerEtAvancer("(");
    noeudSi->ajoute(expBool()); // On mémorise la condition
    testerEtAvancer(")");
    noeudSi->ajoute(seqInst());     // On mémorise la séquence d'instruction
  }
  // le sinon
  if (m_lecteur.getSymbole() == "sinon")
  {
    testerEtAvancer("sinon");
    noeudSi->ajoute(seqInst());     // On mémorise la séquence d'instruction
  }
  testerEtAvancer("finsi");
  return noeudSi; // Et on renvoie un noeud Instruction Si
}

Noeud* Interpreteur::instTantQue()
{
// <instTantQue> ::= tantque ( <expression> ) <seqInst> fintantque
  testerEtAvancer("tantque");
  testerEtAvancer("(");
  Noeud* condition = expBool(); // On mémorise la condition
  testerEtAvancer(")");
  Noeud* sequence = seqInst();     // On mémorise la séquence d'instruction
  testerEtAvancer("fintantque");
  return new NoeudInstTantQue(condition, sequence);
}

Noeud* Interpreteur::instRepeter()
{
  testerEtAvancer("repeter");
  Noeud* sequence = seqInst();     // On mémorise la séquence d'instruction
  testerEtAvancer("jusqua");
  testerEtAvancer("(");
  Noeud* condition = expBool(); // On mémorise la condition
  testerEtAvancer(")");
  return new NoeudInstRepeter(sequence, condition);
}

Noeud* Interpreteur::instPour()
{
  Noeud* affect = nullptr;
  Noeud* affect2 = nullptr;
  testerEtAvancer("pour");
  testerEtAvancer("(");
  if (m_lecteur.getSymbole() == "<VARIABLE>")
  {
    affect = affectation();
  }
  testerEtAvancer(";");
  Noeud* condition = expBool();
  testerEtAvancer(";");
  if (m_lecteur.getSymbole() == "<VARIABLE>")
  {
    affect2 = affectation();
  }

  testerEtAvancer(")");
  Noeud* inst = seqInst();
  testerEtAvancer("finpour");
  return new NoeudInstPour(condition, inst, affect, affect2);
}

Noeud* Interpreteur::instEcrire()
{
  testerEtAvancer("ecrire");
  testerEtAvancer("(");
  Noeud* instEcrire = new NoeudInstEcrire(expBool());
  while (m_lecteur.getSymbole() == ",")
  {
    testerEtAvancer(",");
    instEcrire->ajoute(expBool());
  }
  testerEtAvancer(")");
  testerEtAvancer(";");
  return instEcrire;
}

/**
 * this methods allow reading on standard input as cin (take only the first word of the line !)
 * @return
 */
Noeud* Interpreteur::instLire()
{
  testerEtAvancer("lire");
  testerEtAvancer("(");
  tester("<VARIABLE>");
  Noeud* var = m_table.chercheAjoute(m_lecteur.getSymbole());
  m_lecteur.avancer();
  Noeud* instLire = new NoeudInstLire(var);

  while (m_lecteur.getSymbole() == ",")
  {
    testerEtAvancer(",");
    tester("<VARIABLE>");
    instLire->ajoute(m_table.chercheAjoute(m_lecteur.getSymbole()));
    m_lecteur.avancer();
  }
  testerEtAvancer(")");
  testerEtAvancer(";");
  return instLire;
}

/**
 * <instSelon>::= selon ( <variable> ) cas <ENTIER> : <seqInst> { cas <ENTIER> : <seqInst> } [defaut : <seqInst>] finselon
 * @return
 */
Noeud* Interpreteur::instSelon()
{
  testerEtAvancer("selon");
  testerEtAvancer("(");
  tester("<VARIABLE>");
  Noeud* var = m_table.chercheAjoute(m_lecteur.getSymbole());
  m_lecteur.avancer();
  testerEtAvancer(")");
  Noeud* instSel = new NoeudInstSelon();
  do
  {
    // pour chaque cas
    testerEtAvancer("cas");
    tester("<ENTIER>");
    // on ajoute le nombre correspondant
    Noeud* curNum = m_table.chercheAjoute(m_lecteur.getSymbole());
    instSel->ajoute(
        new NoeudOperateurBinaire(Symbole("=="), var, curNum));
    m_lecteur.avancer();
    testerEtAvancer(":");

    // on ajoute les instructions
    instSel->ajoute(seqInst());
  } while (m_lecteur.getSymbole() == "cas");

  // si il y a un cas defaut
  if (m_lecteur.getSymbole() == "defaut")
  {
    testerEtAvancer("defaut");
    testerEtAvancer(":");
    instSel->ajoute(seqInst());     // On mémorise la séquence d'instruction
  }
  testerEtAvancer("finselon");
  return instSel;
}

